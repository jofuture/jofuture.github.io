## **Q2. 큰 수의 법칙**

#### **문제 설명**

배열의 크기 N,

숫자가 더해지는 횟수 M

연속해서 더할 수 있는 최대값 K

가 주어질 때, 큰 수의 법칙에 따라 더해진 답을 출력하시오.

큰수의 법칙 : 입력된 배열에서 특정 인덱스의 수를 최대 K번 반복하여 더할 수 있고 K번 초과하여 더하면 X

예) N = 5, M = 8, K =3

주어진 배열 : \[2, 4, 5, 4, 6\]

최대값 : 6 + 6 + 6 + 5 + 6 + 6 + 6 + 5 = 46

#### **입력 조건**

첫번째 줄에 N (2 <= N <= 1000), M (1 <= M <= 10000), K (1 <= K <= 10000)의 자연수가 주어지며, 

각 자연수는 공백으로 구분한다.

  
둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분하며 1 이상 10000 이하의 수로 주어진다.  
입력으로 주어지는 K는 항상 M보다 작거나 같다.

#### **출력 조건**

첫째 줄에 동빈이의 큰 수의 법칙에 따라 더해진 답을 출력한다.

```
N, M, K = input().split(" ")
N = int(N)
M = int(M)
K = int(K)

nums = input().split(" ")
for i in range( 0, N ):
    nums[i] = int( nums[i] )

sum = 0
maxNum = max( nums )
nums.remove( maxNum )
maxNum2 = max( nums )

# 리스트안에 최대값이 중복일 때
for i in range( 0, N-1 ):
    if maxNum == nums[i]:
        sum = maxNum * M
        break;

if sum == 0:
    for i in range( 1, M+1 ):
        if i % K == 0:
            sum += maxNum2
        else:
            sum += maxNum

print( sum )
```

## **Q3. 숫자 카드 게임**

####   
**문제 설명**

1\. 숫자가 쓰인 카드들이 N x M 형태로 놓여 있다. 이때 N은 행의 개수를 의미하며, M은 열의 개수를 의미한다.  
2\. 먼저 뽑고자 하는 카드가 포함되어 있는 행을 선택한다.  
3\. 그 다음 선택된 행에 포함된 카드들 중 가장 숫자가 낮은 카드를 뽑아야 한다.  
4. 따라서 처음에 카드를 골라낼 행을 선택할 때, 이후에 해당 행에서 가장 숫자가 낮은 카드를 뽑을 것을 고려하여  
최종적으로 가장 높은 숫자의 카드를 뽑을 수 있도록 전략을 세워야 한다.

#### **입력조건**

\- 첫째 줄에 숫자 카드들이 높인 행의 개수 N과 열의 개수 M이 공백을 기준으로 하여 각각 자연수로 주어진다.  
(1 <= N, M <= 100)  
\- 둘째 줄부터 N개의 줄에 걸쳐 각 카드에 적힌 숫자가 주어진다. 각 숫자는 1 이상 10,000 이하의 자연수이다.

#### **출력조건**

첫째 줄에 게임의 룰에 맞게 선택한 카드에 적힌 숫자를 출력한다.

```
# N, M을 공백으로 구분하여 입력받기
n, m = map(int, input().split())
result = 0

# 한 줄씩 입력받아 확인
for i in range(n) :
  data = list(map(int, input().split()))
  # 현재 줄에서 '가장 작은 수' 찾기
  min_value = min(data)
  # '가장 작은 수'들 중에서 가장 큰 수 찾기
  result = max(result, min_value)

print(result)
```
